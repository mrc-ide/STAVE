[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 MRC Centre Outbreak Analysis Modelling Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/howto_calculating_prevalence.html","id":"matching-variant-strings","dir":"Articles","previous_headings":"","what":"Matching variant strings","title":"Calculating Prevalence","text":"Imagine following data loaded: Prevalence calculation STAVE starts specifying variant interest. example: compared data loaded current object. example, crt:76:T clearly direct match first row, values added numerator denominator. also match second row, contains crt:76:T subset, meaning values also added numerator denominator. gives prevalence = (4 + 1) / (20 + 5) = 20%. Now imagine want know prevalence crt:76:E. match second row terms variant, however, match rows terms position. words, rows produced allele E position 76. Hence, obtain prevalence = 1 / (20 + 5) = 4%. Finally, imagine want know prevalence crt:75_76:ET haplotype. match second row numerator denominator. Hence, obtain prevalence = 1 / 5 = 20%.","code":"s$get_prevalence(target_variant = \"crt:76:T\")"},{"path":"/articles/howto_calculating_prevalence.html","id":"dealing-with-unphased-mixed-calls","dir":"Articles","previous_headings":"","what":"Dealing with unphased mixed calls","title":"Calculating Prevalence","text":"Now let’s look example unphased mixed calls: two common pfcrt haplotypes, CVIET CVMNK, well mixed calls. Imagine want know prevalence crt:72-74:CVI. match first row, interestingly also unambiguous match third row. third variant crt:72-76:CV_I/M_E/N_T/K contains multiple unphased heterozygous sites, meaning work exact component haplotypes make mixture. However, looking solely positions 72 74, know certain haplotypes CVI CVM present. Therefore can certain matches target. obtain prevalence = (50 + 10) / 100 = 60%. Now imagine want know prevalence full crt:72-76:CVMNK haplotype. matches second row, multiple unphased heterozygous sites third row, ambiguous match variant. target may present samples, equally may . presents problem - include numerator risk overestimating prevalence, exclude risk underestimating prevalence. Faced dilemma, approach taken STAVE simply report minimum maximum possible prevalence implied data. give min_prevalence = 40 / 100 = 40%, max_prevalence = (40 + 10) / 100 = 50%. user decide information. Valid approaches include taking min, max, midpoint, advanced statistical imputation based per-locus prevalence. Whatever choice made, clearly documented.","code":""},{"path":"/articles/howto_calculating_prevalence.html","id":"dealing-with-phased-mixed-calls","dir":"Articles","previous_headings":"","what":"Dealing with phased mixed calls","title":"Calculating Prevalence","text":"Finally, imagine data , now mixed haplotype encoded phased information: mixtures now clearly specified combination CVIET CVMNK haplotypes. target crt:72-76:CVMNK , now unambiguous match second third rows, giving prevalence = (40 + 10) / 100 = 50%. strong argument including phased data wherever possible, although reality can challenging reliably phase genomes. complex situations, partial phasing two alleles locus, allowed - see variantstring package documentation details. next page goes explain ways must careful entering interpreting data.","code":""},{"path":"/articles/howto_cautionary_notes.html","id":"do-i-need-to-record-wild-type-samples","dir":"Articles","previous_headings":"","what":"Do I need to record wild type samples?","title":"Cautionary Notes","text":"table encodes mutant haplotypes interest also often wild-type pfcrt haplotype (CVMNK) observed. Notice sum numerators across variants equals denominator. tells us entire space possible haplotypes covered. data complete, can query prevalence allele locus obtain correct result. example, prevalence wild-type allele (C) codon 72: correct - C allele seen 20 times CVIET mutant haplotype 70 times WT CVMNK haplotype. Therefore prevalence (20 + 70) / 100 = 90%. However, many studies report many samples wild-type. Instead, report “interesting” haplotypes — typically carrying resistance-associated mutations. dataset , difference WT observations omitted: happens now attempt estimate prevalence 72 C? result clearly wrong: estimate 20% far low. happens , WT haplotype omitted, remaining records C allele codon 72 come samples mutant somewhere else haplotype. true WT samples invisible STAVE, counted. naturally raises question: always record WT haplotypes numerators sum denominator? ideal world, yes. complete distribution haplotypes known, including WT observations, many downstream queries become trivial robust. practice, often impossible : authors focused certain mutations, meaning assume unreported haplotypes WT, reference genome used analysis stated, data already summarised reaching . WT samples recorded, STAVE invent . resulting prevalence estimates therefore biased toward mutants, uncertainty intervals reflect partial data.","code":"s$get_prevalence(target_variant = \"crt:72:C\") |>   ... # (further filters to only show some columns) s$get_prevalence(target_variant = \"crt:72:C\") |>   ... # (further filters to only show some columns)"},{"path":"/articles/howto_cautionary_notes.html","id":"practical-implications","dir":"Articles","previous_headings":"Do I need to record wild type samples?","what":"Practical implications","title":"Cautionary Notes","text":"WT count available, include — prevents many errors. available, cautious querying allele-level prevalence, especially positions wild-type reference haplotype (e.g. mdr1 N86).","code":""},{"path":"/articles/howto_cautionary_notes.html","id":"restricted-or-identifying-data","dir":"Articles","previous_headings":"","what":"Restricted or identifying data","title":"Cautionary Notes","text":"STAVE designed handle public non-public datasets. access_level field allows users mark study public, restricted, private, STAVE places limitations loading analysing restricted material. design choice allows individual laboratories surveillance teams use STAVE internal datasets, even datasets shared publicly. However, also means users entirely responsible ensuring STAVE objects containing restricted private data enter public domain. STAVE provides structure, enforce data-governance rules; must respected analysts use . second consideration relates identifiability. Aggregate genetic data often assumed non-identifying represent groups rather individuals. However, STAVE encourages high-resolution spatial recording sampling locations, sufficiently fine granularity assumption may break . example, single individual presents precisely geo-referenced health facility specific day, data identifying even aggregated form. reason, users must ensure spatial temporal resolution data ethically legally appropriate. may require intentionally reducing precision — example, jittering, rounding, otherwise anonymising coordinates constructing STAVE object. steps taken, clearly documented location_notes (, relevant, time_notes) fields downstream user understands provenance limitations spatial information. read documentation point, god bless ! good understanding STAVE works, ready jump Installation Tutorials sections start putting ideas practice.","code":""},{"path":"/articles/howto_core_design_principles.html","id":"linkage-of-genetic-data-to-precise-space-time-coordinates","dir":"Articles","previous_headings":"","what":"Linkage of genetic data to precise space-time coordinates","title":"Core Design Principles","text":"Genetic data often linked places using descriptive fields like country name, name administrative area, “site” name. flexible, brings lot ambiguity. site might mean clinic, village, district, something else entirely, different contributors rarely use term way. makes hard compare data across studies can result mixed levels spatial granularity within single dataset. Using free-text location names also unreliable. Take Côte d’Ivoire example: might appear Ivory Coast, Cote d’Ivoire, Côte d’Ivoire, Republic Côte d’Ivoire, many variations look almost identical. small differences can stop datasets joining cleanly, example grouping country, common source accidental data duplication. Many projects try avoid using country administrative codes ISO-2, ISO-3, GADM IDs. helps, introduces new problem: administrative boundaries codes stable time. Countries split, rename, merge; administrative units redrawn; every coding system forces data provider choose one particular version. means codes can become source inconsistency unless chosen boundary set carefully documented version-controlled. Time information can just messy. datasets record sampling year, can mask interesting patterns places strong seasonality. Others describe time vague terms like “mid-2014” “rainy season”, leaves much room interpretation. STAVE takes deliberately strict approach issues requiring precise spatial coordinates (latitude longitude) specific day collection every survey. Although may seem rigid, simply reflects reality: sampling event occurs single place time - ambiguity comes data recorded, sampling . insisting explicit spatial temporal anchors, STAVE makes clean separation data recording administrative interpretive layers sit top . Country administrative boundaries can always derived later intersecting coordinates version-controlled shapefile. main downside approach sometimes requires imputing spatial temporal information original data vague incomplete. STAVE accepts trade-: precise coordinates dates resolves least many problems imputation introduces. support , STAVE includes free-text fields users can document spatial temporal values inferred. Even imputation coarse — example, taking midpoint reported sampling range — creates transparent record locations dates determined. explicitness helps maintain data provenance motivates users obtain accurate raw information available.","code":""},{"path":"/articles/howto_core_design_principles.html","id":"flexible-encoding-of-haplotypes","dir":"Articles","previous_headings":"","what":"Flexible encoding of haplotypes","title":"Core Design Principles","text":"Existing approaches encoding non-synonymous mutations, .e. change amino acid code, solve part problem none fully meet needs MMS. de-facto shorthand — N86Y single codons CVMNK multi-locus pfcrt haplotypes — wonderfully compact easy write, provides consistent rules representing mixed phased calls, different groups often improvise conventions. extreme, formats like VCF standards HGVS GA4GH VRS offer highly structured, rigorous ways describe alleles, haplotypes, genotypes, including heterozygosity phasing DNA level. However, designed individual-level, nucleotide-resolved data become either irrelevant (e.g. phasing differences collapse amino acid) extremely verbose applied short haplotypes often found MMS. Sitting top statistical issues related prevalence estimation. example, haplotype two unphased mixed calls becomes statistically impossible know 100% confidence whether particular haplotype present within mixture. However, focus short sub-region haplotype one fewer mixed loci issue goes away, can resolve haplotypes exactly. Therefore, question encode data vs. estimate prevalence data exactly thing, ideal encoding allow prevalence estimation using available information. clear gap lightweight, human-readable encoding still rich enough capture features needed prevalence estimation. motivation behind developing variantstring format: compact, human-readable way encode amino-acid variation sits informal shorthand like CVMNK heavyweight standards like HGVS VRS. example, simple pfcrt haplotype can written unphased mixture CVIET CVMNK haplotypes can written short enough manually entered needed - example extracting data academic publications. aggregated count data, variantstring can paired numerator (number samples variant appears) denominator (number samples successfully sequenced relevant loci). encoded way, STAVE can compute prevalence subset haplotype — example, just codon 76 pfcrt, codons 72–75 excluding 76 — checking samples unambiguous information exactly positions. example, unphased mixture shown , assert presence CVIET haplotype , can say codon 74 contains M alleles.","code":"pfcrt:72-76:CVIET pfcrt:72-76:C_V_I/M_E/N_T/K"},{"path":"/articles/howto_core_design_principles.html","id":"relational-structure","dir":"Articles","previous_headings":"","what":"Relational structure","title":"Core Design Principles","text":"Aggregated genetic data rarely live comfortably single flat table. Instead, involve several distinct layers: study-level context (generated data ), survey-level context (samples collected), genetic measurements . layers mixed together leads redundant information entered multiple times, bloats file sizes creates opportunities data entry mistakes. simple relational structure helps avoid problems separating concerns: kind information stored , place naturally belongs, tables link back . STAVE uses three-table relational layout built around idea: studies, surveys, counts. studies table holds stable identifier (study_id), contains information data provenance. Several studies may share reference (e.g. URL), may represent internal unpublished work. key point every survey every set counts can traced back study identifier summarises “dataset belongs ”. surveys table holds stable identifier (survey_id), represents unit sampling space time. survey defined single sampling event (tightly bounded collection period) specific location. STAVE, anchored latitude, longitude, collection day, optional start/end dates free-text notes spatial temporal imputation. survey links exactly one study_id. counts table stores genetic measurements, linking observed variant exactly one survey_id. row contains variantstring observed haplotype, associated numerator denominator. aggregated information non-synonymous mutations lives, always context specific survey study. next pages go specific formatting requirements three linked tables.","code":""},{"path":"/articles/howto_counts_table.html","id":"fields-and-requirements","dir":"Articles","previous_headings":"","what":"Fields and requirements","title":"The Counts Table","text":"Mandatory fields shown blue.","code":""},{"path":"/articles/howto_counts_table.html","id":"variantstring-format","dir":"Articles","previous_headings":"","what":"variantstring format","title":"The Counts Table","text":"variantstring format defined variantstring package - refer package documentation details. current version STAVE uses variantstring v1.8.3. next page demonstrates nuances encoding genetic data.","code":""},{"path":"/articles/howto_encoding_data.html","id":"encoding-single-locus-data","dir":"Articles","previous_headings":"","what":"Encoding single-locus data","title":"Encoding Genetic Data","text":"Imagine come across paper detailing pfcrt mutations codons 72 76 sample 100 individuals. CVIET haplotype, commonly observed positions, well-established marker chloroquine resistance. However, rather presenting haplotype-level data, paper provides site-specific information: number individuals tested codon frequency observed variant: Notice total_num consistent loci. common, usually caused loci failing amplify samples. method encoding genetic data straightforward easy interpret. instance, prevalence glutamic acid (E) codon 75 can directly calculated 20 92 samples, approximately 22%. However, approach sacrifices information full haplotypes. Specifically, determine whether 20 samples crt:75:E individuals also carry crt:76:T. result, limited estimating single-locus prevalences infer multi-locus patterns linkage. encoding valid, suboptimal analyses rely haplotype structure.","code":""},{"path":"/articles/howto_encoding_data.html","id":"encoding-multi-locus-data","dir":"Articles","previous_headings":"","what":"Encoding multi-locus data","title":"Encoding Genetic Data","text":"Now imagine different study encodes complete haplotypes: first two rows show results samples amplified successfully loci 72 76. Notice denominator 65 two rows. general, denominator must identical rows share combination genes positions. 65 samples produced either two variants, grouped together denominator class. next two rows describe samples amplified subset loci. denominator gives number samples amplified subset. match subsets relates different combination genes positions. Importantly, double counting table. crt:72-76:CVIET samples included crt:72-74:CVI numbers, even though technically amplify loci. ’re ever unsure , remember every sample present table . reason, incorrect table also list single-locus prevalences calculated full haplotypes. STAVE smart enough calculate single-locus prevalences full haplotype data, encoding information twice result double-counting. encoding generally preferable method information can calculated data.","code":""},{"path":"/articles/howto_encoding_data.html","id":"encoding-mixed-calls","dir":"Articles","previous_headings":"","what":"Encoding mixed calls","title":"Encoding Genetic Data","text":"third example muti-locus haplotypes well mixed calls loci: See variant string package details encode mixed calls, short, / symbol specifies un-phased mixed call, | phased mixed call. samples amplified successfully positions 72 74, therefore denominator 100 shared rows. various combinations mixed calls given different row. Samples crt:72-74:C/S_VI also contained numbers crt:72-74:CVI. always, samples appear .","code":""},{"path":"/articles/howto_encoding_data.html","id":"how-many-loci-is-too-many","dir":"Articles","previous_headings":"","what":"How many loci is too many?","title":"Encoding Genetic Data","text":"Consider final example, phased information presented multiple genes (scroll see full table): long variant string. one hand, encoding full haplotype retains information. hand, notation starts become quite cumbersome. took approach large number samples reach combinatorial explosion number possible observed variants positions, distinct variant require new row. different approach might break different genes: reduces number possible combinations, new rows needed capture diversity gene. However, lost ability query prevalence haplotypes spanning multiple genes. example, may interested frequently dhfr dhps mutations found together, now lost us broken data. Overall, balance strike capturing everything capturing enough. balance vary one application next. general, aim capture genome-wide haplotypes STAVE probably best solution. may better sticking common formats like VCF PMO. aim capture key drug resistance combinations lightweight flexible notation, STAVE may good choice. next page goes details prevalence calculated encoded data.","code":""},{"path":"/articles/howto_studies_table.html","id":"fields-and-requirements","dir":"Articles","previous_headings":"","what":"Fields and requirements","title":"The Studies Table","text":"Mandatory fields shown blue.","code":""},{"path":"/articles/howto_studies_table.html","id":"valid-identifiers","dir":"Articles","previous_headings":"","what":"Valid identifiers","title":"The Studies Table","text":"relational keys must valid identifiers. means : Contain English letters (uppercase lowercase), numbers (0-9), underscores (_). begin number underscore. Beyond restrictions, naming convention can used. However, recommended adopt systematic approach avoid potential conflicts. instance, using generic IDs like “study1” good idea, IDs overlap datasets (although STAVE prevent appending study ID matching existing loaded study). better approach use concise, descriptive format, first author’s surname year publication academic paper, e.g., Bloggs_2024. next page shows specify location time data Surveys table.","code":""},{"path":"/articles/howto_surveys_table.html","id":"fields-and-requirements","dir":"Articles","previous_headings":"","what":"Fields and requirements","title":"The Surveys Table","text":"Mandatory fields shown blue. next page shows encode genetic data Counts table.","code":""},{"path":"/articles/installation.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Installation","text":"can install recent version STAVE using: good practice specify version number ensure scripts run even package changes time. install specific version can use @ symbol follows: see “Tags” section main Github page latest version number.","code":"# install.packages(\"remotes\") remotes::install_github(\"mrc-ide/STAVE\") remotes::install_github(\"mrc-ide/STAVE@v2.0.2\")"},{"path":"/articles/tutorial_calculating_prevalence.html","id":"calculating-prevalence","dir":"Articles","previous_headings":"","what":"Calculating prevalence","title":"Calculating Prevalence","text":"Let’s begin creating new STAVE object appending example data: calculating prevalence, often useful inspect set variants encoded object: default, get_variants() lists single-locus variants. instead want see multi-locus haplotypes, set: (example difference multi-locus haplotypes loaded).","code":"# create new object s <- STAVE_object$new()  # append example data s$append_data(studies_dataframe = example_input$studies,               surveys_dataframe = example_input$surveys,               counts_dataframe = example_input$counts) #> data correctly appended s$get_variants() #> [1] \"crt:76:T\"  \"k13:469:F\" \"k13:469:Y\" \"k13:675:V\" \"mdr1:86:Y\" s$get_variants(report_haplo = TRUE) #> [1] \"crt:76:T\"  \"k13:469:F\" \"k13:469:Y\" \"k13:675:V\" \"mdr1:86:Y\""},{"path":"/articles/tutorial_calculating_prevalence.html","id":"prevalence-at-a-single-locus","dir":"Articles","previous_headings":"Calculating prevalence","what":"Prevalence at a single locus","title":"Calculating Prevalence","text":"calculate prevalence specific variant, use get_prevalence(). example, prevalence mutation crt:76:T: output joined table containing study, survey, count information, well estimated prevalence 95% confidence interval survey. Note row every loaded survey, even denominator zero. return surveys non-zero denominators, use:","code":"s$get_prevalence(target_variant = \"crt:76:T\") s$get_prevalence(target_variant = \"crt:76:T\", return_full = FALSE)"},{"path":"/articles/tutorial_calculating_prevalence.html","id":"prevalence-of-a-haploype-and-ambiguous-matches","dir":"Articles","previous_headings":"Calculating prevalence","what":"Prevalence of a haploype, and ambiguous matches","title":"Calculating Prevalence","text":"another example, time allowing ambiguous matches. min max numerator now given. example ambiguity calculating prevalence single locus, longer haplotypes min max can differ. prevalence 95% CI calculated using either min max values, specified prev_from_min argument.","code":"s$get_prevalence(\"crt:76:T\", keep_ambiguous = TRUE, prev_from_min = TRUE)"},{"path":"/articles/tutorial_reading_in_data.html","id":"reading-in-data","dir":"Articles","previous_headings":"","what":"Reading in data","title":"Reading in Data","text":"STAVE works via single class (R6 object) acts main data container. class allows users efficiently import, store, manipulate data via specialized member functions. new object can created data read like : three data frames must follow specific formats required STAVE. See works sections unclear format. data conform structure, append rejected. default print method tells us many studies surveys loaded: Using custom class offers several key advantages. loaded, data remain consolidated within single object, avoiding fragmentation. class structure also ensures data encapsulated, meaning directly edited user. built-protection minimizes risk accidental data corruption. can view loaded tables using get functions: However, directly modify data tables. Instead, modify data structure using member functions.","code":"# create new object s <- STAVE_object$new()  # append data using a member function s$append_data(studies_dataframe = example_input$studies,               surveys_dataframe = example_input$surveys,               counts_dataframe = example_input$counts) #> data correctly appended s #> Studies: 2 #> Surveys: 6 s$get_studies() s$get_surveys() s$get_counts()"},{"path":"/articles/tutorial_reading_in_data.html","id":"dropping-studies-and-surveys","dir":"Articles","previous_headings":"","what":"Dropping studies and surveys","title":"Reading in Data","text":"Imagine interested study Dama et al. (2017), want drop analysis. can via study_id: Similarly, may want drop specific survey - example Asua_2019_Agago_2017 survey: Looking STAVE object, can see reduced size data: free append information back point, point go usual rigorous checks.","code":"s$drop_study(\"Dama_2017\") #> drop 1 study, 1 survey s$drop_survey(\"Asua_2019_Agago_2017\") #> drop 0 studies, 1 survey s #> Studies: 1 #> Surveys: 4"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Bob Verity. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Verity B (2025). STAVE: Spatial-Temporal Aggregated Variant Encoding. R package version 2.0.2.","code":"@Manual{,   title = {STAVE: Spatial-Temporal Aggregated Variant Encoding},   author = {Bob Verity},   year = {2025},   note = {R package version 2.0.2}, }"},{"path":"/index.html","id":"what-stave-is-designed-to-do","dir":"","previous_headings":"","what":"What STAVE is designed to do","title":"Spatial-Temporal Aggregated Variant Encoding","text":"STAVE focuses small number key tasks commonly cause errors inconsistencies MMS workflows: Provide simple, relational data structure storing study metadata, survey-level space–time information, aggregated genetic counts. Encode haplotypes non-synonymous mutations (.e. changes amino acid) compact, human-readable format using variantstring format. Support robust prevalence estimation, even variants represent subsets longer haplotypes mixed calls introduce uncertainty. STAVE deliberately minimal: attempt handle individual-level data, nucleotide-level data, downstream spatial modelling. Instead, aims slot cleanly broader analysis workflows providing reliable unambiguous foundation steps can build.","code":""},{"path":"/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting started","title":"Spatial-Temporal Aggregated Variant Encoding","text":"learn STAVE data structure works, see works. ’re ready start working package, visit: Installation – install package Tutorials – practical examples common tasks","code":""},{"path":"/reference/STAVE_object.html","id":null,"dir":"Reference","previous_headings":"","what":"STAVE data object (R6 class) — STAVE_object","title":"STAVE data object (R6 class) — STAVE_object","text":"main class stores data responsible data input, output, processing functions. functionality STAVE package class form member functions.","code":""},{"path":"/reference/STAVE_object.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"STAVE data object (R6 class) — STAVE_object","text":"raw data stored private variables within object, meaning () edited directly. Rather, tables can extracted using get_counts() similarly tables. three tables : studies: Information data came , example url     author names. study indexed unique study_id. surveys: Information surveys represented within study.     survey defined discrete instance data collection,     includes information geography (latitude longitude) collection     time. Surveys given survey_ids linked particular study     study_id. counts: actual genetic information, linked     particular study survey study_id survey_id. Genetic     variants encoded character strings must follow specified     format, number times variant observed among total     sample stored columns. combination linked tables allows efficient flexible encoding variants, avoiding unnecessary duplication information.","code":""},{"path":[]},{"path":"/reference/STAVE_object.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"STAVE data object (R6 class) — STAVE_object","text":"STAVE_object$print() STAVE_object$get_studies() STAVE_object$get_surveys() STAVE_object$get_counts() STAVE_object$get_version() STAVE_object$append_data() STAVE_object$get_prevalence() STAVE_object$get_variants() STAVE_object$drop_study() STAVE_object$drop_survey() STAVE_object$clone()","code":""},{"path":"/reference/STAVE_object.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"STAVE data object (R6 class) — STAVE_object","text":"Custom print method control console output","code":""},{"path":"/reference/STAVE_object.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$print()"},{"path":"/reference/STAVE_object.html","id":"method-get-studies-","dir":"Reference","previous_headings":"","what":"Method get_studies()","title":"STAVE data object (R6 class) — STAVE_object","text":"Extract studies data.frames stored within object","code":""},{"path":"/reference/STAVE_object.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_studies()"},{"path":"/reference/STAVE_object.html","id":"method-get-surveys-","dir":"Reference","previous_headings":"","what":"Method get_surveys()","title":"STAVE data object (R6 class) — STAVE_object","text":"Extract surveys data.frames stored within object","code":""},{"path":"/reference/STAVE_object.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_surveys()"},{"path":"/reference/STAVE_object.html","id":"method-get-counts-","dir":"Reference","previous_headings":"","what":"Method get_counts()","title":"STAVE data object (R6 class) — STAVE_object","text":"Extract counts data.frames stored within object","code":""},{"path":"/reference/STAVE_object.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_counts()"},{"path":"/reference/STAVE_object.html","id":"method-get-version-","dir":"Reference","previous_headings":"","what":"Method get_version()","title":"STAVE data object (R6 class) — STAVE_object","text":"Extract version number STAVE object. important member functions STAVE object directly linked object , updated updating version package environment. update STAVE object new package version, first extract data load new STAVE object created recent version.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_version()"},{"path":"/reference/STAVE_object.html","id":"method-append-data-","dir":"Reference","previous_headings":"","what":"Method append_data()","title":"STAVE data object (R6 class) — STAVE_object","text":"Append new data","code":""},{"path":"/reference/STAVE_object.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$append_data(   studies_dataframe,   surveys_dataframe,   counts_dataframe )"},{"path":"/reference/STAVE_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"studies_dataframe data frame containing information study level. data frame must following columns: study_id, study_label, description, access_level, contributors, reference, reference_year, PMID, notes. Compulsory fields (missing values) : study_id reference. surveys_dataframe data frame containing information survey level. data.frame must following columns: study_id, survey_id, country_name, site_name, latitude, longitude, location_method, location_notes, collection_start, collection_end, collection_day, time_method, time_notes. Compulsory fields (missing values) : study_id, survey_id, latitude, longitude, collection_day. counts_dataframe data.frame genetic information. Must contain following columns: study_id, survey_id, variant_string, variant_num, total_num, notes. non-compulsory field notes.","code":""},{"path":"/reference/STAVE_object.html","id":"method-get-prevalence-","dir":"Reference","previous_headings":"","what":"Method get_prevalence()","title":"STAVE data object (R6 class) — STAVE_object","text":"Calculate prevalence","code":""},{"path":"/reference/STAVE_object.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_prevalence(   target_variant,   keep_ambiguous = FALSE,   prev_from_min = TRUE,   return_full = TRUE )"},{"path":"/reference/STAVE_object.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"target_variant variant calculate prevalence, example crt:72:C. can heterozygous calls within string. keep_ambiguous may variants data target_variant sample, proven conclusively. example, sequence A_A_A may match sequence /C_A/C_A, may . unphased genotypes sure. keep_ambiguous = TRUE min max numerator reported either include ambiguous calls matches (max) exclude mismatches (min). FALSE (default) ambiguous calls skipped , may downwardly bias prevalence calculation. prev_from_min output object includes point estimate prevalence along exact binomial confidence intervals. case ambiguous calls, must calculated one numerator_min numerator_max. argument sets one values used calculation. Defaults TRUE, risks underestimating prevalence (whereas alternative risks overestimating prevalence). return_full TRUE (default) returns entire loaded dataset, prevalence equal NA denominator. FALSE returns entries non-zero denominator. @import dplyr @importFrom tidyr replace_na","code":""},{"path":"/reference/STAVE_object.html","id":"method-get-variants-","dir":"Reference","previous_headings":"","what":"Method get_variants()","title":"STAVE data object (R6 class) — STAVE_object","text":"Return vector variants present data object.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_variants(report_haplo = FALSE)"},{"path":"/reference/STAVE_object.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"report_haplo (Boolean) TRUE list haplotypes. Otherwise, list locus--locus format. Defaults FALSE.","code":""},{"path":"/reference/STAVE_object.html","id":"method-drop-study-","dir":"Reference","previous_headings":"","what":"Method drop_study()","title":"STAVE data object (R6 class) — STAVE_object","text":"Drop one study_ids data. drop internally stored data objects, including corresponding surveys counts data.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$drop_study(drop_study_id)"},{"path":"/reference/STAVE_object.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"drop_study_id vector study_ids drop data objects.","code":""},{"path":"/reference/STAVE_object.html","id":"method-drop-survey-","dir":"Reference","previous_headings":"","what":"Method drop_survey()","title":"STAVE data object (R6 class) — STAVE_object","text":"Drop one survey_ids data. drop internally stored data objects, including corresponding counts data, study survey study.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$drop_survey(drop_survey_id)"},{"path":"/reference/STAVE_object.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"drop_survey_id vector survey_ids drop data objects.","code":""},{"path":"/reference/STAVE_object.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"STAVE data object (R6 class) — STAVE_object","text":"objects class cloneable method.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$clone(deep = FALSE)"},{"path":"/reference/STAVE_object.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"deep Whether make deep clone.","code":""},{"path":"/reference/example_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Input Dataset — example_input","title":"Example Input Dataset — example_input","text":"list containing three data.frames make STAVE object. correctly formatted, can used reference formatting data. studies come much reduced version WWARN data antimalarial resistance.","code":""},{"path":"/reference/example_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Input Dataset — example_input","text":"","code":"example_input"},{"path":"/reference/example_input.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Input Dataset — example_input","text":"list containing three data.frames","code":""},{"path":"/reference/example_input.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example Input Dataset — example_input","text":"","code":"data(\"example_input\", package = \"STAVE\")"}]
