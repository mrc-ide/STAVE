[{"path":"/articles/calculating_prevalence.html","id":"matching-variant-strings","dir":"Articles","previous_headings":"","what":"Matching variant strings","title":"Calculating Prevalence","text":"Imagine following data loaded: Prevalence calculation STAVE starts specifying variant interest variantstring format. compared data loaded current object. example, imagine want know prevalence crt:76:T. clearly direct match first row, values added numerator denominator. also match second row, contains crt:76:T subset, meaning values also added numerator denominator. gives prevalence = (4 + 1) / (20 + 5) = 20%. Now imagine want know prevalence crt:76:E. match second row terms variant, however, match rows terms position. Hence, obtain prevalence = 1 / (20 + 5) = 4%. Finally, imagine want know prevalence crt:75_76:ET haplotype. match second row numerator denominator. obtain prevalence = 1 / 5 = 20%.","code":""},{"path":"/articles/calculating_prevalence.html","id":"dealing-with-unphased-mixed-calls","dir":"Articles","previous_headings":"","what":"Dealing with unphased mixed calls","title":"Calculating Prevalence","text":"Now let’s look example unphased mixed calls: two common pfcrt haplotypes, CVIET CVMNK, well mixed calls. Imagine want know prevalence crt:72-74:CVI. match first row, interestingly also unambiguous match third row. third variant crt:72-76:CV_I/M_E/N_T/K contains multiple unphased heterozygous sites, meaning work exact component haplotypes make mixture. However, looking solely positions 72 74, know certain haplotypes CVI CVM present. Therefore can certain matches target. obtain prevalence = (50 + 10) / 100 = 60%. Now imagine want know prevalence full crt:72-76:CVMNK haplotype. matches second row, multiple unphased heterozygous sites third row, ambiguous match variant. target may present samples, equally may . presents problem - include numerator risk overestimating prevalence, exclude risk underestimating. Faced dilemma, approach taken STAVE simply report minimum maximum possible prevalence implied data. give min_prevalence = 40 / 100 = 40%, max_prevalence = (40 + 10) / 100 = 50%. user decide .","code":""},{"path":"/articles/calculating_prevalence.html","id":"dealing-with-phased-mixed-calls","dir":"Articles","previous_headings":"","what":"Dealing with phased mixed calls","title":"Calculating Prevalence","text":"Finally, imagine data , now mixed haplotype encoded phased information: mixtures now clearly specified combination CVIET CVMNK haplotypes. target crt:72-76:CVMNK , now unambiguous match second third rows, giving prevalence = (40 + 10) / 100 = 50%. strong argument including phased data wherever possible, although reality can challenging reliably phase genomes. complex situations, partial phasing two alleles locus, allowed - see variantstring package documentation details. next page goes explain ways must careful entering interpreting data.","code":""},{"path":"/articles/cautionary_notes.html","id":"do-i-need-to-record-wild-type-samples","dir":"Articles","previous_headings":"","what":"Do I need to record wild type samples?","title":"Cautionary Notes","text":"table encodes mutant haplotypes interest also often wild-type pfcrt haplotype (CVMNK) observed. Notice sum numerators across variants equals denominator. tells us entire space possible haplotypes covered. data complete, can query prevalence allele locus obtain correct result. example, prevalence wild-type allele (C) codon 72: correct - C allele seen 20 times CVIET mutant haplotype 70 times WT CVMNK haplotype. However, many studies report many samples wild-type. Instead, report “interesting” haplotypes — typically carrying resistance-associated mutations. dataset , difference WT observations omitted: happens now attempt estimate prevalence 72 C? result clearly wrong: estimate far low. happens , WT haplotype omitted, remaining records C allele codon 72 come samples mutant somewhere else haplotype. true WT samples invisible STAVE, counted. naturally raises question: always record WT haplotypes numerators sum denominator? ideal world, yes. complete distribution haplotypes known, including WT observations, many downstream queries become trivial robust. practice, often impossible : authors focused certain mutations, meaning assume unreported haplotypes WT, reference genome used analysis stated, data already summarised reaching . WT samples recorded, STAVE invent . resulting prevalence estimates therefore biased toward mutants, uncertainty intervals reflect partial data.","code":""},{"path":"/articles/cautionary_notes.html","id":"practical-implications","dir":"Articles","previous_headings":"","what":"Practical implications","title":"Cautionary Notes","text":"WT count available, include — prevents many errors. available, cautious querying allele-level prevalence, especially positions wild-type reference haplotype. mutant haplotypes reported, safest queries target exactly mutations reported, complements. read documentation point, bless . good understanding STAVE works, ready jump Installation Tutorials sections start putting ideas practice.","code":""},{"path":"/articles/core_design_principles.html","id":"linkage-of-genetic-data-to-precise-space-time-coordinates","dir":"Articles","previous_headings":"","what":"Linkage of genetic data to precise space-time coordinates","title":"Core Design Principles","text":"Genetic data often linked places using descriptive fields like country name, administrative area, “site” name. flexible, brings lot ambiguity. site might mean clinic, village, district, something else entirely, different contributors rarely use term way. makes hard compare data across studies can result mixed levels spatial granularity within single dataset. Using free-text location names also unreliable. Take Côte d’Ivoire: might appear Ivory Coast, Cote d’Ivoire, Côte d’Ivoire, Republic Côte d’Ivoire, many variations look almost identical. small differences can stop datasets joining cleanly, example grouping country, common source accidental data duplication. Many projects try avoid using country administrative codes ISO-2, ISO-3, GADM IDs. helps, introduces new problem: administrative boundaries codes stable time. Countries split, rename, merge; administrative units redrawn; every coding system forces data provider choose one particular version. means codes can become source inconsistency unless chosen boundary set carefully documented version-controlled. Time information can just messy. datasets record sampling year, can mask interesting patterns places strong seasonality. Others describe time vague terms like “mid-2014” “rainy season”, leaves much room interpretation. STAVE takes deliberately strict approach issues requiring precise spatial coordinates (latitude longitude) specific day collection every survey. Although may seem rigid, simply reflects reality: sampling event occurs single place time - ambiguity comes data recorded, sampling . insisting explicit spatial temporal anchors, STAVE makes clean separation data recording administrative interpretive layers sit top . Country administrative boundaries can always derived later intersecting coordinates version-controlled shapefile. main downside approach sometimes requires imputing spatial temporal information original data vague incomplete. STAVE accepts trade-: precise coordinates dates resolves least many problems imputation introduces. support , STAVE includes free-text fields users can document spatial temporal values inferred. Even imputation coarse — example, taking midpoint reported sampling range — creates transparent record locations dates determined. explicitness helps maintain data provenance motivates users obtain accurate raw information available.","code":""},{"path":"/articles/core_design_principles.html","id":"flexible-encoding-of-haplotypes","dir":"Articles","previous_headings":"","what":"Flexible encoding of haplotypes","title":"Core Design Principles","text":"Existing approaches encoding non-synonymous mutations, .e. change amino acid code, solve part problem none fully meet needs MMS. de-facto shorthand — N86Y single codons CVMNK pfcrt haplotypes — wonderfully compact easy write, provides consistent rules representing mixed phased calls, different groups often improvise conventions. extreme, formats like VCF standards HGVS GA4GH VRS offer highly structured, rigorous ways describe alleles, haplotypes, genotypes, including heterozygosity phasing DNA level. However, designed individual-level, nucleotide-resolved data become either irrelevant (e.g. phasing differences collapse amino acid) extremely verbose applied short haplotypes. clear gap something : lightweight, human-readable encoding still rich enough capture features needed prevalence estimation. motivation behind developing variantstring format: compact, human-readable way encode amino-acid variation sits informal shorthand like CVMNK heavyweight standards like HGVS VRS. example, simple pfcrt haplotype can written unphased mixture CVIET CVMNK haplotypes can written short enough manually entered needed - example extracting data academic publications. thinking aggregated count data, variantstring can paired numerator (number samples variant appears) denominator (number samples successfully sequenced relevant loci). encoded way, STAVE can compute prevalence subset haplotype — example, just codon 76 pfcrt, codons 72–75 excluding 76 — checking samples unambiguous information exactly positions. example, unphased mixture shown , assert presence CVIET haplotype , can say codon 74 contains M alleles.","code":"pfcrt:72-76:CVIET pfcrt:72-76:C_V_I/M_E/N_T/K"},{"path":"/articles/core_design_principles.html","id":"relational-structure","dir":"Articles","previous_headings":"","what":"Relational structure","title":"Core Design Principles","text":"Aggregated genetic data rarely live comfortably single flat table. Instead, involve several distinct layers: study-level context (generated data ), survey-level context (samples collected), genetic measurements . layers mixed together leads redundant information entered multiple times, bloats file sizes creates opportunities data entry mistakes. simple relational structure helps avoid problems separating concerns: kind information stored , place naturally belongs, tables link back . STAVE uses three-table relational layout built around idea: studies, surveys, counts. studies table holds stable identifier (study_id), short label, reference (e.g. DOI, URL, internal code), access level, additional notes description. entries describe logical datasets analyses rather claiming one--one mapping publications. particular, several studies may share publication project, may represent internal unpublished work. key point every survey every set counts can traced back study identifier summarises “dataset belongs ”. surveys table represents unit sampling space time. survey defined single sampling event (tightly bounded collection period) specific location. STAVE, anchored latitude, longitude, collection day, optional start/end dates free-text notes spatial temporal imputation. survey links exactly one study via study_id. counts table stores genetic measurements, linking observed variant exactly one survey via survey_id. row contains survey_id, variantstring observed haplotype, associated numerator denominator. aggregated information non-synonymous mutations lives, always context specific survey study. next pages go specific formatting requirements three linked tables. prefer get stuck code, tutorials use example dataset pre-loaded package demonstrate core functionalities.","code":""},{"path":"/articles/counts_format.html","id":"encoding-single-locus-data","dir":"Articles","previous_headings":"","what":"Encoding single-locus data","title":"Encoding Genetic Data","text":"Imagine come across paper detailing pfcrt mutations codons 72 76 sample 100 individuals. CVIET haplotype, commonly observed positions, well-established marker chloroquine resistance. However, rather presenting haplotype-level data, paper provides site-specific information: number individuals tested codon frequency observed variant: Notice total_num consistent loci. common, usually caused loci failing amplify samples. method encoding genetic data straightforward easy interpret. instance, prevalence glutamic acid (“E”) codon 75 can directly calculated 20 92 samples, approximately 22%. However, approach sacrifices information full haplotypes. Specifically, determine whether 20 samples crt:75:E individuals also carry crt:76:T. result, limited estimating single-locus prevalences infer multi-locus patterns linkage. encoding valid, suboptimal analyses rely haplotype structure.","code":""},{"path":"/articles/counts_format.html","id":"encoding-multi-locus-data","dir":"Articles","previous_headings":"","what":"Encoding multi-locus data","title":"Encoding Genetic Data","text":"Now imagine different study encodes complete haplotypes: first two rows show results samples amplified successfully loci 72 76. Notice denominator 65 two rows. general, denominator must identical rows share combination genes positions. 65 samples produced either two variants, grouped together denominator class. next two rows describe samples amplified subset codons. denominator gives number samples amplified subset. match subsets relates different combination genes positions. Importantly, double counting table. crt:72_73_74_75_76:CVIET samples included crt:72_73_74:CVI numbers, even though technically amplify loci. ’re ever unsure , remember every sample present table . reason, incorrect table also list single-locus prevalences calculated full haplotypes. STAVE smart enough calculate single-locus prevalences full haplotype data, encoding information twice result double-counting.","code":""},{"path":"/articles/counts_format.html","id":"encoding-mixed-calls","dir":"Articles","previous_headings":"","what":"Encoding mixed calls","title":"Encoding Genetic Data","text":"third example muti-locus haplotypes well mixed calls loci: See variant string package details encode mixed calls, short, / symbol specifies un-phased mixed call, | phased mixed call. samples amplified successfully positions 72 74, therefore denominator 100 shared rows. various combinations mixed calls given different row. Samples crt:72_73_74:C/S_VI also contained numbers crt:72_73_74:CVI - always, samples appear .","code":""},{"path":"/articles/counts_format.html","id":"how-many-loci-is-too-many","dir":"Articles","previous_headings":"","what":"How many loci is too many?","title":"Encoding Genetic Data","text":"Consider final example, phased information presented multiple genes: long variant string. one hand, encoding full haplotype retains information. hand, notation starts become quite cumbersome. importantly, took approach large number samples reach combinatorial explosion number possible observed variants positions, distinct variant require new row. different approach might break different genes: reduce number possible combinations, new rows needed capture diversity gene. However, lost ability query prevalence haplotypes spanning multiple genes. example, may interested frequently dhfr dhps mutations found together, now lost us broken data. Overall, balance strike capturing everything capturing enough. balance vary one application next. general, aim capture genome-wide haplotypes STAVE probably best solution, may better sticking common formats like .vcf .pmo. aim capture key drug resistance combinations lightweight flexible notation, STAVE may good choice. next page goes details calculating prevalence encoded data.","code":""},{"path":"/articles/counts_table.html","id":"fields-and-requirements","dir":"Articles","previous_headings":"","what":"Fields and requirements","title":"The Counts Table","text":"Mandatory fields shown blue.","code":""},{"path":"/articles/counts_table.html","id":"variantstring-format","dir":"Articles","previous_headings":"","what":"variantstring format","title":"The Counts Table","text":"variantstring format defined variantstring package - refer package documentation details. version STAVE uses variantstring v1.8.3. next page demonstrates nuances encoding genetic data, important avoid data duplication.","code":""},{"path":"/articles/encoding_data.html","id":"encoding-single-locus-data","dir":"Articles","previous_headings":"","what":"Encoding single-locus data","title":"Encoding Genetic Data","text":"Imagine come across paper detailing pfcrt mutations codons 72 76 sample 100 individuals. CVIET haplotype, commonly observed positions, well-established marker chloroquine resistance. However, rather presenting haplotype-level data, paper provides site-specific information: number individuals tested codon frequency observed variant: Notice total_num consistent loci. common, usually caused loci failing amplify samples. method encoding genetic data straightforward easy interpret. instance, prevalence glutamic acid (E) codon 75 can directly calculated 20 92 samples, approximately 22%. However, approach sacrifices information full haplotypes. Specifically, determine whether 20 samples crt:75:E individuals also carry crt:76:T. result, limited estimating single-locus prevalences infer multi-locus patterns linkage. encoding valid, suboptimal analyses rely haplotype structure.","code":""},{"path":"/articles/encoding_data.html","id":"encoding-multi-locus-data","dir":"Articles","previous_headings":"","what":"Encoding multi-locus data","title":"Encoding Genetic Data","text":"Now imagine different study encodes complete haplotypes: first two rows show results samples amplified successfully loci 72 76. Notice denominator 65 two rows. general, denominator must identical rows share combination genes positions. 65 samples produced either two variants, grouped together denominator class. next two rows describe samples amplified subset codons. denominator gives number samples amplified subset. match subsets relates different combination genes positions. Importantly, double counting table. crt:72-76:CVIET samples included crt:72-74:CVI numbers, even though technically amplify loci. ’re ever unsure , remember every sample present table . reason, incorrect table also list single-locus prevalences calculated full haplotypes. STAVE smart enough calculate single-locus prevalences full haplotype data, encoding information twice result double-counting.","code":""},{"path":"/articles/encoding_data.html","id":"encoding-mixed-calls","dir":"Articles","previous_headings":"","what":"Encoding mixed calls","title":"Encoding Genetic Data","text":"third example muti-locus haplotypes well mixed calls loci: See variant string package details encode mixed calls, short, / symbol specifies un-phased mixed call, | phased mixed call. samples amplified successfully positions 72 74, therefore denominator 100 shared rows. various combinations mixed calls given different row. Samples crt:72-74:C/S_VI also contained numbers crt:72-74:CVI - always, samples appear .","code":""},{"path":"/articles/encoding_data.html","id":"how-many-loci-is-too-many","dir":"Articles","previous_headings":"","what":"How many loci is too many?","title":"Encoding Genetic Data","text":"Consider final example, phased information presented multiple genes: long variant string. one hand, encoding full haplotype retains information. hand, notation starts become quite cumbersome. took approach large number samples reach combinatorial explosion number possible observed variants positions, distinct variant require new row. different approach might break different genes: reduces number possible combinations, new rows needed capture diversity gene. However, lost ability query prevalence haplotypes spanning multiple genes. example, may interested frequently dhfr dhps mutations found together, now lost us broken data. Overall, balance strike capturing everything capturing enough. balance vary one application next. general, aim capture genome-wide haplotypes STAVE probably best solution. may better sticking common formats like VCF PMO. aim capture key drug resistance combinations lightweight flexible notation, STAVE may good choice. next page goes details calculating prevalence encoded data.","code":""},{"path":"/articles/howto_calculating_prevalence.html","id":"matching-variant-strings","dir":"Articles","previous_headings":"","what":"Matching variant strings","title":"Calculating Prevalence","text":"Imagine following data loaded: Prevalence calculation STAVE starts specifying variant interest variantstring format. example: compared data loaded current object. example, imagine want know prevalence crt:76:T. clearly direct match first row, values added numerator denominator. also match second row, contains crt:76:T subset, meaning values also added numerator denominator. gives prevalence = (4 + 1) / (20 + 5) = 20%. Now imagine want know prevalence crt:76:E. match second row terms variant, however, match rows terms position. words, rows produced allele E position 76. Hence, obtain prevalence = 1 / (20 + 5) = 4%. Finally, imagine want know prevalence crt:75_76:ET haplotype. match second row numerator denominator. Hence, obtain prevalence = 1 / 5 = 20%.","code":"s$get_prevalence(target_variant = \"crt:76:T\")"},{"path":"/articles/howto_calculating_prevalence.html","id":"dealing-with-unphased-mixed-calls","dir":"Articles","previous_headings":"","what":"Dealing with unphased mixed calls","title":"Calculating Prevalence","text":"Now let’s look example unphased mixed calls: two common pfcrt haplotypes, CVIET CVMNK, well mixed calls. Imagine want know prevalence crt:72-74:CVI. match first row, interestingly also unambiguous match third row. third variant crt:72-76:CV_I/M_E/N_T/K contains multiple unphased heterozygous sites, meaning work exact component haplotypes make mixture. However, looking solely positions 72 74, know certain haplotypes CVI CVM present. Therefore can certain matches target. obtain prevalence = (50 + 10) / 100 = 60%. Now imagine want know prevalence full crt:72-76:CVMNK haplotype. matches second row, multiple unphased heterozygous sites third row, ambiguous match variant. target may present samples, equally may . presents problem - include numerator risk overestimating prevalence, exclude risk underestimating prevalence. Faced dilemma, approach taken STAVE simply report minimum maximum possible prevalence implied data. give min_prevalence = 40 / 100 = 40%, max_prevalence = (40 + 10) / 100 = 50%. user decide information. Valid approaches include taking min, max, midpoint, advanced statistical imputation based per-locus prevalence. Whatever choice made, clearly documented.","code":""},{"path":"/articles/howto_calculating_prevalence.html","id":"dealing-with-phased-mixed-calls","dir":"Articles","previous_headings":"","what":"Dealing with phased mixed calls","title":"Calculating Prevalence","text":"Finally, imagine data , now mixed haplotype encoded phased information: mixtures now clearly specified combination CVIET CVMNK haplotypes. target crt:72-76:CVMNK , now unambiguous match second third rows, giving prevalence = (40 + 10) / 100 = 50%. strong argument including phased data wherever possible, although reality can challenging reliably phase genomes. complex situations, partial phasing two alleles locus, allowed - see variantstring package documentation details. next page goes explain ways must careful entering interpreting data.","code":""},{"path":"/articles/howto_cautionary_notes.html","id":"do-i-need-to-record-wild-type-samples","dir":"Articles","previous_headings":"","what":"Do I need to record wild type samples?","title":"Cautionary Notes","text":"table encodes mutant haplotypes interest also often wild-type pfcrt haplotype (CVMNK) observed. Notice sum numerators across variants equals denominator. tells us entire space possible haplotypes covered. data complete, can query prevalence allele locus obtain correct result. example, prevalence wild-type allele (C) codon 72: correct - C allele seen 20 times CVIET mutant haplotype 70 times WT CVMNK haplotype. Therefore prevalence (20 + 70) / 100 = 90%. However, many studies report many samples wild-type. Instead, report “interesting” haplotypes — typically carrying resistance-associated mutations. dataset , difference WT observations omitted: happens now attempt estimate prevalence 72 C? result clearly wrong: estimate 20% far low. happens , WT haplotype omitted, remaining records C allele codon 72 come samples mutant somewhere else haplotype. true WT samples invisible STAVE, counted. naturally raises question: always record WT haplotypes numerators sum denominator? ideal world, yes. complete distribution haplotypes known, including WT observations, many downstream queries become trivial robust. practice, often impossible : authors focused certain mutations, meaning assume unreported haplotypes WT, reference genome used analysis stated, data already summarised reaching . WT samples recorded, STAVE invent . resulting prevalence estimates therefore biased toward mutants, uncertainty intervals reflect partial data.","code":"s$get_prevalence(target_variant = \"crt:72:C\") |>   ... # (only show some columns) s$get_prevalence(target_variant = \"crt:72:C\") |>   ... # (only show some columns)"},{"path":"/articles/howto_cautionary_notes.html","id":"practical-implications","dir":"Articles","previous_headings":"Do I need to record wild type samples?","what":"Practical implications","title":"Cautionary Notes","text":"WT count available, include — prevents many errors. available, cautious querying allele-level prevalence, especially positions wild-type reference haplotype (e.g. mdr1 N86). mutant haplotypes reported, safest queries target exactly mutations reported, complements.","code":""},{"path":"/articles/howto_cautionary_notes.html","id":"restricted-or-identifying-data","dir":"Articles","previous_headings":"","what":"Restricted or identifying data","title":"Cautionary Notes","text":"STAVE designed handle public non-public datasets. access_level field allows users mark study public, restricted, private, STAVE places limitations loading analysing restricted material. design choice allows individual laboratories surveillance teams use STAVE internal datasets, even datasets shared publicly. However, also means users entirely responsible ensuring STAVE objects containing restricted private data enter public domain. STAVE provides structure, enforce data-governance rules; must respected analysts use . second consideration relates identifiability. Aggregate genetic data often assumed non-identifying represent groups rather individuals. However, STAVE encourages high-resolution spatial recording sampling locations, sufficiently fine granularity assumption may break . example, single individual presents precisely geo-referenced health facility specific day, data identifying even aggregated form. reason, users must ensure spatial temporal resolution data ethically legally appropriate. may require intentionally reducing precision — example, jittering, rounding, otherwise pseudonymising coordinates constructing STAVE object. steps taken, clearly documented location_notes (, relevant, time_notes) fields downstream user understands provenance limitations spatial information. read documentation point, bless ! good understanding STAVE works, ready jump Installation Tutorials sections start putting ideas practice.","code":""},{"path":"/articles/howto_core_design_principles.html","id":"linkage-of-genetic-data-to-precise-space-time-coordinates","dir":"Articles","previous_headings":"","what":"Linkage of genetic data to precise space-time coordinates","title":"Core Design Principles","text":"Genetic data often linked places using descriptive fields like country name, name administrative area, “site” name. flexible, brings lot ambiguity. site might mean clinic, village, district, something else entirely, different contributors rarely use term way. makes hard compare data across studies can result mixed levels spatial granularity within single dataset. Using free-text location names also unreliable. Take Côte d’Ivoire: might appear Ivory Coast, Cote d’Ivoire, Côte d’Ivoire, Republic Côte d’Ivoire, many variations look almost identical. small differences can stop datasets joining cleanly, example grouping country, common source accidental data duplication. Many projects try avoid using country administrative codes ISO-2, ISO-3, GADM IDs. helps, introduces new problem: administrative boundaries codes stable time. Countries split, rename, merge; administrative units redrawn; every coding system forces data provider choose one particular version. means codes can become source inconsistency unless chosen boundary set carefully documented version-controlled. Time information can just messy. datasets record sampling year, can mask interesting patterns places strong seasonality. Others describe time vague terms like “mid-2014” “rainy season”, leaves much room interpretation. STAVE takes deliberately strict approach issues requiring precise spatial coordinates (latitude longitude) specific day collection every survey. Although may seem rigid, simply reflects reality: sampling event occurs single place time - ambiguity comes data recorded, sampling . insisting explicit spatial temporal anchors, STAVE makes clean separation data recording administrative interpretive layers sit top . Country administrative boundaries can always derived later intersecting coordinates version-controlled shapefile. main downside approach sometimes requires imputing spatial temporal information original data vague incomplete. STAVE accepts trade-: precise coordinates dates resolves least many problems imputation introduces. support , STAVE includes free-text fields users can document spatial temporal values inferred. Even imputation coarse — example, taking midpoint reported sampling range — creates transparent record locations dates determined. explicitness helps maintain data provenance motivates users obtain accurate raw information available.","code":""},{"path":"/articles/howto_core_design_principles.html","id":"flexible-encoding-of-haplotypes","dir":"Articles","previous_headings":"","what":"Flexible encoding of haplotypes","title":"Core Design Principles","text":"Existing approaches encoding non-synonymous mutations, .e. change amino acid code, solve part problem none fully meet needs MMS. de-facto shorthand — N86Y single codons CVMNK pfcrt haplotypes — wonderfully compact easy write, provides consistent rules representing mixed phased calls, different groups often improvise conventions. extreme, formats like VCF standards HGVS GA4GH VRS offer highly structured, rigorous ways describe alleles, haplotypes, genotypes, including heterozygosity phasing DNA level. However, designed individual-level, nucleotide-resolved data become either irrelevant (e.g. phasing differences collapse amino acid) extremely verbose applied short haplotypes often found MMS. clear gap something : lightweight, human-readable encoding still rich enough capture features needed prevalence estimation. motivation behind developing variantstring format: compact, human-readable way encode amino-acid variation sits informal shorthand like CVMNK heavyweight standards like HGVS VRS. example, simple pfcrt haplotype can written unphased mixture CVIET CVMNK haplotypes can written short enough manually entered needed - example extracting data academic publications - also containing rich information ambiguities. aggregated count data, variantstring can paired numerator (number samples variant appears) denominator (number samples successfully sequenced relevant loci). encoded way, STAVE can compute prevalence subset haplotype — example, just codon 76 pfcrt, codons 72–75 excluding 76 — checking samples unambiguous information exactly positions. example, unphased mixture shown , assert presence CVIET haplotype , can say codon 74 contains M alleles. separating encoding genetic information prevalence variant, maintain flexibility rigour.","code":"pfcrt:72-76:CVIET pfcrt:72-76:C_V_I/M_E/N_T/K"},{"path":"/articles/howto_core_design_principles.html","id":"relational-structure","dir":"Articles","previous_headings":"","what":"Relational structure","title":"Core Design Principles","text":"Aggregated genetic data rarely live comfortably single flat table. Instead, involve several distinct layers: study-level context (generated data ), survey-level context (samples collected), genetic measurements . layers mixed together leads redundant information entered multiple times, bloats file sizes creates opportunities data entry mistakes. simple relational structure helps avoid problems separating concerns: kind information stored , place naturally belongs, tables link back . STAVE uses three-table relational layout built around idea: studies, surveys, counts. studies table holds stable identifier (study_id), contains information data provenance. Several studies may share reference (e.g. URL), may represent internal unpublished work. key point every survey every set counts can traced back study identifier summarises “dataset belongs ”. surveys table holds stable identifier (survey_id), represents unit sampling space time. survey defined single sampling event (tightly bounded collection period) specific location. STAVE, anchored latitude, longitude, collection day, optional start/end dates free-text notes spatial temporal imputation. survey links exactly one study_id. counts table stores genetic measurements, linking observed variant exactly one survey_id. row contains variantstring observed haplotype, associated numerator denominator. aggregated information non-synonymous mutations lives, always context specific survey study. next pages go specific formatting requirements three linked tables. prefer get stuck code, tutorials use example dataset comes pre-loaded STAVE.","code":""},{"path":"/articles/howto_counts_table.html","id":"fields-and-requirements","dir":"Articles","previous_headings":"","what":"Fields and requirements","title":"The Counts Table","text":"Mandatory fields shown blue.","code":""},{"path":"/articles/howto_counts_table.html","id":"variantstring-format","dir":"Articles","previous_headings":"","what":"variantstring format","title":"The Counts Table","text":"variantstring format defined variantstring package - refer package documentation details. current version STAVE uses variantstring v1.8.3. next page demonstrates nuances encoding genetic data.","code":""},{"path":"/articles/howto_encoding_data.html","id":"encoding-single-locus-data","dir":"Articles","previous_headings":"","what":"Encoding single-locus data","title":"Encoding Genetic Data","text":"Imagine come across paper detailing pfcrt mutations codons 72 76 sample 100 individuals. CVIET haplotype, commonly observed positions, well-established marker chloroquine resistance. However, rather presenting haplotype-level data, paper provides site-specific information: number individuals tested codon frequency observed variant: Notice total_num consistent loci. common, usually caused loci failing amplify samples. method encoding genetic data straightforward easy interpret. instance, prevalence glutamic acid (E) codon 75 can directly calculated 20 92 samples, approximately 22%. However, approach sacrifices information full haplotypes. Specifically, determine whether 20 samples crt:75:E individuals also carry crt:76:T. result, limited estimating single-locus prevalences infer multi-locus patterns linkage. encoding valid, suboptimal analyses rely haplotype structure.","code":""},{"path":"/articles/howto_encoding_data.html","id":"encoding-multi-locus-data","dir":"Articles","previous_headings":"","what":"Encoding multi-locus data","title":"Encoding Genetic Data","text":"Now imagine different study encodes complete haplotypes: first two rows show results samples amplified successfully loci 72 76. Notice denominator 65 two rows. general, denominator must identical rows share combination genes positions. 65 samples produced either two variants, grouped together denominator class. next two rows describe samples amplified subset loci. denominator gives number samples amplified subset. match subsets relates different combination genes positions. Importantly, double counting table. crt:72-76:CVIET samples included crt:72-74:CVI numbers, even though technically amplify loci. ’re ever unsure , remember every sample present table . reason, incorrect table also list single-locus prevalences calculated full haplotypes. STAVE smart enough calculate single-locus prevalences full haplotype data, encoding information twice result double-counting.","code":""},{"path":"/articles/howto_encoding_data.html","id":"encoding-mixed-calls","dir":"Articles","previous_headings":"","what":"Encoding mixed calls","title":"Encoding Genetic Data","text":"third example muti-locus haplotypes well mixed calls loci: See variant string package details encode mixed calls, short, / symbol specifies un-phased mixed call, | phased mixed call. samples amplified successfully positions 72 74, therefore denominator 100 shared rows. various combinations mixed calls given different row. Samples crt:72-74:C/S_VI also contained numbers crt:72-74:CVI - always, samples appear .","code":""},{"path":"/articles/howto_encoding_data.html","id":"how-many-loci-is-too-many","dir":"Articles","previous_headings":"","what":"How many loci is too many?","title":"Encoding Genetic Data","text":"Consider final example, phased information presented multiple genes (scroll see full table): long variant string. one hand, encoding full haplotype retains information. hand, notation starts become quite cumbersome. took approach large number samples reach combinatorial explosion number possible observed variants positions, distinct variant require new row. different approach might break different genes: reduces number possible combinations, new rows needed capture diversity gene. However, lost ability query prevalence haplotypes spanning multiple genes. example, may interested frequently dhfr dhps mutations found together, now lost us broken data. Overall, balance strike capturing everything capturing enough. balance vary one application next. general, aim capture genome-wide haplotypes STAVE probably best solution. may better sticking common formats like VCF PMO. aim capture key drug resistance combinations lightweight flexible notation, STAVE may good choice. next page goes details calculating prevalence encoded data.","code":""},{"path":"/articles/howto_studies_table.html","id":"fields-and-requirements","dir":"Articles","previous_headings":"","what":"Fields and requirements","title":"The Studies Table","text":"Mandatory fields shown blue.","code":""},{"path":"/articles/howto_studies_table.html","id":"valid-identifiers","dir":"Articles","previous_headings":"","what":"Valid identifiers","title":"The Studies Table","text":"relational keys must valid identifiers. means : Contain English letters (uppercase lowercase), numbers (0-9), underscores (_). begin number underscore. Beyond restrictions, naming convention can used. However, recommended adopt systematic approach avoid potential conflicts. instance, using generic IDs like “study1” good idea, IDs overlap datasets (although STAVE prevent appending study ID matching existing loaded study). better approach use concise, descriptive format, first author’s surname year publication academic paper, e.g., Bloggs_2024. next page shows specify location time data Surveys table.","code":""},{"path":"/articles/howto_surveys_table.html","id":"fields-and-requirements","dir":"Articles","previous_headings":"","what":"Fields and requirements","title":"The Surveys Table","text":"Mandatory fields shown blue. next page shows encode genetic data Counts table.","code":""},{"path":"/articles/input_formats.html","id":"a-custom-data-class","dir":"Articles","previous_headings":"","what":"A custom data class","title":"Input Formats","text":"STAVE works via single class (R6 object) acts main data container. class allows users efficiently import, store, manipulate genetic data via specialized member functions. example, new object can created data read like : example uses example_input object comes pre-loaded package. Notice append_data() function attached object, accessed via $ symbol. Using custom class offers several key advantages. loaded, data remain consolidated within single object, avoiding fragmentation. class structure also ensures data encapsulated, meaning directly edited user. built-protection minimizes risk accidental data corruption. STAVE performs battery rigorous checks data import process. checks cover wide range validations, ensuring proper character formatting verifying prevalences exceed 100%. data pass checks, successfully loaded object. , import rejected, informative error message provided. core principle STAVE modify input data import. instance, column headers dataset contain capital letters lowercase allowed, STAVE automatically convert — even though ! Instead reject import. strict approach ensures users fully aware exact structure input data, meaning single format used universally anyone using STAVE. downside must conform strictly structure order use package. remainder page specifies formatting requirements three input tables.","code":"# create new object s <- STAVE_object$new()  # append data using a member function s$append_data(studies_dataframe = example_input$studies,               surveys_dataframe = example_input$surveys,               counts_dataframe = example_input$surveys)"},{"path":"/articles/input_formats.html","id":"the-studies-table","dir":"Articles","previous_headings":"","what":"The Studies table","title":"Input Formats","text":"table captures information origin data. example correctly formatted Studies table given : mandatory fields study_id url. Please ensure URLs accurate permanent, serve sole external reference verifying origin data. fields optional, meaning cells can left blank, although column headings must still included. optional fields minimal formatting requirements primarily intended storing descriptive information help quickly identify study. exception study_type, must adhere predefined set options (see ).","code":""},{"path":"/articles/input_formats.html","id":"study-ids","dir":"Articles","previous_headings":"The Studies table","what":"Study IDs","title":"Input Formats","text":"Study IDs must “valid identifiers”, meaning must: Contain English letters (uppercase lowercase), numbers (0-9), underscores (_). begin number underscore. Beyond restrictions, naming convention can used. However, recommended adopt systematic approach avoid potential conflicts. instance, using generic IDs like “study1” good idea, IDs overlap datasets, causing issues combining data. better approach use concise, descriptive format, first author’s surname year publication, e.g., Bloggs_2024.","code":""},{"path":"/articles/input_formats.html","id":"data-types","dir":"Articles","previous_headings":"The Studies table","what":"Data types","title":"Input Formats","text":"column rules data type: entries study_type private warning message printed data imported. warning prevent data loaded, flags user private data present case intentional.","code":""},{"path":"/articles/input_formats.html","id":"the-surveys-table","dir":"Articles","previous_headings":"","what":"The Surveys table","title":"Input Formats","text":"Surveys table captures information context within data collected. can think survey single instance data collection. example correctly formatted Surveys table given : Notice study_key links back Studies table. table must include fields latitude, longitude, collection_day. cases, information might directly available raw data. example, locations may reported regional level, collection periods might span entire season. Nonetheless, STAVE strictly enforces requirement data must provided single point space time. several reasons strict requirement: Support spatial modeling methods: Many spatial methods, modeling prevalence continuous surface space time, rely precise point-level data. methods struggle accommodate areal data, prevalence reported province level. Avoidance ambiguity location reporting: Using spatial coordinates eliminates ambiguities associated place names. instance, “Côte d’Ivoire” also appear “Cote d’Ivoire” (without accents), “Republic Côte d’Ivoire,” “Ivory Coast,” many variations. issue even pronounced site names, interpretations may vary — example, name health facility versus name nearby village. Even standardized identifiers like ISO 3166 country codes can pose challenges, countries political boundaries may change time. Latitude longitude inherently stable precise, making reliable method identifying collection locations. Note Surveys table includes fields country_name, site_name, collection_start collection_end, however, fields solely convenience. allow users quickly scan table identify data collected. Ideally, used spatial analysis. robust approach overlay spatial coordinates shapefile (e.g., GADM) determine country region survey, use country identifier analysis, rather value stored country_name. method enables country-level analysis avoiding risks errors ambiguities associated inconsistent conflicting country names. exact locations collection timings unavailable, data imputation may necessary. example, centroid region used approximate spatial location, midpoint collection range estimate timing. cases, optional fields spatial_notes time_notes used document methods assumptions applied data preparation.","code":""},{"path":"/articles/input_formats.html","id":"survey-ids","dir":"Articles","previous_headings":"The Surveys table","what":"Survey IDs","title":"Input Formats","text":"Study IDs, Survey IDs must valid identifiers. survey ID can reused across different studies, example two studies can include survey ID “south_district”, ID found twice within study throw error. ensures integrity relational links allowing flexibility across studies.","code":""},{"path":"/articles/input_formats.html","id":"collection-times","dir":"Articles","previous_headings":"The Surveys table","what":"Collection times","title":"Input Formats","text":"Dates always tricky issue many different possible conventions. STAVE requires dates stored YYYY-MM-DD format, example valid date \"2024-01-19\". avoids confusion caused regional date formats, example MM/DD/YYYY common US vs. DD/MM/YYYY common Europe. also added advantage dates sortable numerically. Dates represented character strings. need convert specific Date class using packages like lubridate.","code":""},{"path":"/articles/input_formats.html","id":"data-types-1","dir":"Articles","previous_headings":"The Surveys table","what":"Data types","title":"Input Formats","text":"column rules data type:","code":""},{"path":"/articles/input_formats.html","id":"the-counts-table","dir":"Articles","previous_headings":"","what":"The Counts table","title":"Input Formats","text":"final table Counts table, stores genetic information. example correctly formatted Counts table given : columns table compulsory. variant_string format defined variantstring package - see package documentation details. variant_num gives number times variant observed, total_num gives number times locus combination loci successfully sequenced. can think variant_num numerator prevalence calculation, total_num denominator.","code":""},{"path":"/articles/input_formats.html","id":"data-types-2","dir":"Articles","previous_headings":"The Counts table","what":"Data types","title":"Input Formats","text":"column rules data type: next page shows encode genetic data Counts table.","code":""},{"path":"/articles/installation.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Installation","text":"can install recent version STAVE using: good practice specify version number ensure scripts run even package changes time (backward-compatibility guaranteed). install specific version can use following format: see “Tags” section main Github page latest version number.","code":"# install.packages(\"devtools\") devtools::install_github(\"mrc-ide/STAVE\") devtools::install_github(\"mrc-ide/STAVE@v2.0.0\")"},{"path":"/articles/reading_in_data.html","id":"reading-in-data","dir":"Articles","previous_headings":"","what":"Reading in data","title":"Reading in Data and Calculating Prevalence","text":"STAVE works via single class (R6 object) acts main data container. class allows users efficiently import, store, manipulate data via specialized member functions. new object can created data read like : default print method tells us many studies surveys loaded: example uses example_input object comes pre-loaded package - look object get feel required input format (see rest package documentation rigorous specification). Using custom class offers several key advantages. loaded, data remain consolidated within single object, avoiding fragmentation. class structure also ensures data encapsulated, meaning directly edited user. built-protection minimizes risk accidental data corruption. can view loaded tables using get functions: However, directly modify data tables. Instead, drop studies surveys using member functions.","code":"# create new object s <- STAVE_object$new()  # append data using a member function s$append_data(studies_dataframe = example_input$studies,               surveys_dataframe = example_input$surveys,               counts_dataframe = example_input$counts) #> data correctly appended s #> Studies: 2 #> Surveys: 6 s$get_studies() s$get_surveys() s$get_counts()"},{"path":"/articles/reading_in_data.html","id":"dropping-studies-and-surveys","dir":"Articles","previous_headings":"","what":"Dropping studies and surveys","title":"Reading in Data and Calculating Prevalence","text":"Imagine interested study Dama et al. (2017), want drop analysis. can via study_id: Similarly, may want drop specific survey - example Asua_2019_Agogo_2017 survey: Looking STAVE object, can see reduced data:","code":"s$drop_study(\"Dama_2017\") #> drop 1 study, 1 survey #s$drop_survey(\"Asua_2019_Agogo_2017\") s #> Studies: 1 #> Surveys: 5"},{"path":"/articles/reading_in_data.html","id":"calculating-prevalence","dir":"Articles","previous_headings":"","what":"Calculating prevalence","title":"Reading in Data and Calculating Prevalence","text":"can calculate prevalence variant using get_prevalence(). appends information together studies surveys, final columns giving prevalence (%) lower upper 95% CIs: Notice results given every loaded survey, even corresponding genetic data calculate prevalence. instead want rows non-zero denominator, use argument return_full = FALSE. another example, time allowing ambiguous matches. min max numerator now given. still single prevalence estimate 95% CI, calculated using either min max values, specified prev_from_min argument.","code":"s$get_variants() #> [1] \"k13:469:F\" \"k13:469:Y\" \"k13:675:V\" s$get_prevalence(\"k13:469:Y\") s$get_prevalence(\"k13:469:Y\", keep_ambiguous = TRUE, prev_from_min = TRUE)"},{"path":"/articles/relational_structure.html","id":"whats-the-issue","dir":"Articles","previous_headings":"","what":"What’s the issue?","title":"The Relational Structure","text":"Imagine ’ve extracted data genetic variants academic paper now building table organize results. Often, single paper contain multiple entries — example, row might correspond different sampling location. ensure others can trace results back original source, ’ll need include information paper table, example author list year publication. However, raises common issue: duplicate details every row table? one hand, duplicating information ensures variant counts always linked source, crucial reproducibility. hand, introduces redundancy, increasing file size unnecessarily heightening risk data entry errors.","code":""},{"path":"/articles/relational_structure.html","id":"the-solution","dir":"Articles","previous_headings":"","what":"The solution","title":"The Relational Structure","text":"Fortunately, common class problem, well-known solution use relational database structure. approach, unique IDs employed link fields across multiple tables. One table store metadata paper (e.g., authors, year publication etc.), second table hold data genetic variants (e.g., gene name, counts). two tables connected relational key, key tables links related information. setup avoids redundancy, minimizes errors, maintains clear link data source. STAVE, split data three tables: Studies: record data came . academic publications, reports, sources. Surveys: define survey discrete instance data collection. Survey-level data include information location (latitude longitude) time (day) collection. may multiple surveys within given study, example different sampling sites different collection periods may come academic publication. Counts: aggregate genetic data stored. Fields include name variant observed (.e. gene, locus, mutation), many times observed (numerator), many times successfully tested (denominator). three tables linked two sets keys.","code":""},{"path":"/articles/relational_structure.html","id":"why-use-an-r-package","dir":"Articles","previous_headings":"","what":"Why use an R package?","title":"The Relational Structure","text":"many software platforms specifically designed managing relational databases, notable examples MySQL Oracle. STAVE written R? reasons : Many downstream tools written R, making convenient stay within environment. Although R missing advanced features solutions tailored relational databases (e.g. allowing synchronous editing avoiding clashes), also needed simple application. R excellent capabilities writing general functions, e.g. visualisation mapping. R language choice, making fastest option develop maintain package. next page goes specific formatting requirements three linked tables.","code":""},{"path":"/articles/studies_table.html","id":"fields-and-requirements","dir":"Articles","previous_headings":"","what":"Fields and requirements","title":"The Studies Table","text":"Mandatory fields shown blue.","code":""},{"path":"/articles/studies_table.html","id":"valid-identifiers","dir":"Articles","previous_headings":"","what":"Valid identifiers","title":"The Studies Table","text":"relational keys must valid identifiers. means : Contain English letters (uppercase lowercase), numbers (0-9), underscores (_). begin number underscore. Beyond restrictions, naming convention can used. However, recommended adopt systematic approach avoid potential conflicts. instance, using generic IDs like “study1” good idea, IDs overlap datasets (although STAVE prevent appending study ID matching existing loaded study). better approach use concise, descriptive format, first author’s surname year publication academic paper, e.g., Bloggs_2024. next page shows specify location time data Surveys table.","code":""},{"path":"/articles/surveys_table.html","id":"fields-and-requirements","dir":"Articles","previous_headings":"","what":"Fields and requirements","title":"The Surveys Table","text":"Mandatory fields shown blue. next page shows encode genetic data Counts table.","code":""},{"path":"/articles/tutorial_basic.html","id":"example-workflow","dir":"Articles","previous_headings":"","what":"Example workflow","title":"tutorial_basic","text":"Input data take form three tables. use pre-loaded example data , using data need match input format: Create STAVE object append data: data loaded, can always view different tables using get functions. However, alter values directly. can calculate prevalence variant using get_prevalence(): can also return list variants data: Finally, can selectively drop studies data using study ID:","code":"library(STAVE)  data(\"example_input\") #View(example_input$studies) #View(example_input$surveys) #View(example_input$counts) # create new object s <- STAVE_object$new()  # append data using a member function s$append_data(studies_dataframe = example_input$studies,               surveys_dataframe = example_input$surveys,               counts_dataframe = example_input$counts) #> data correctly appended # check how many studies are now loaded s #> Studies: 7 #> Surveys: 24 s$get_studies() |> head() #> # A tibble: 6 × 6 #>   study_ID            study_name       study_type authors publication_year url   #>   <chr>               <chr>            <chr>      <chr>              <dbl> <chr> #> 1 wwarn_10297_Nelson  wwarn_10297_Nel… peer_revi… Nelson              1000 http… #> 2 wwarn_10814_Dama    wwarn_10814_Dama peer_revi… Dama                1000 http… #> 3 wwarn_10992_Mallick wwarn_10992_Mal… peer_revi… Mallick             1000 http… #> 4 wwarn_11208_Kunasol wwarn_11208_Kun… peer_revi… Kunasol             1000 http… #> 5 wwarn_11435_Henry   wwarn_11435_Hen… peer_revi… Henry               1000 http… #> 6 wwarn_11720_Ould    wwarn_11720_Ould peer_revi… Ould                1000 http… s$get_surveys() |> head() #> # A tibble: 6 × 11 #>   study_key           survey_ID country_name site_name   lat   lon spatial_notes #>   <chr>               <chr>     <chr>        <chr>     <dbl> <dbl> <chr>         #> 1 wwarn_10297_Nelson  wwarn_10… Thailand     Kanchana…  15.3 98.5  wwarn lat an… #> 2 wwarn_10814_Dama    wwarn_10… Mali         Koulikoro  12.6 -8.14 wwarn lat an… #> 3 wwarn_10992_Mallick wwarn_10… India        Chhattis…  20.1 80.8  wwarn lat an… #> 4 wwarn_10992_Mallick wwarn_10… India        Goa        15.3 74.1  wwarn lat an… #> 5 wwarn_10992_Mallick wwarn_10… India        Gujarat    23.0 73.6  wwarn lat an… #> 6 wwarn_10992_Mallick wwarn_10… India        Heilongj…  88.3 27.2  wwarn lat an… #> # ℹ 4 more variables: collection_start <chr>, collection_end <chr>, #> #   collection_day <chr>, time_notes <chr> s$get_counts() |> head() #> # A tibble: 6 × 4 #>   survey_key                           variant_string variant_num total_num #>   <chr>                                <chr>                <dbl>     <dbl> #> 1 wwarn_10297_Nelson_Sangkhlaburi_2002 mdr1:184:F              27        49 #> 2 wwarn_10297_Nelson_Sangkhlaburi_2002 mdr1:86:Y                4        49 #> 3 wwarn_10814_Dama_Bamako_2014         crt:76:T               130       170 #> 4 wwarn_10814_Dama_Bamako_2014         mdr1:86:Y               46       158 #> 5 wwarn_10992_Mallick_Assam_2002       crt:76:T                26        26 #> 6 wwarn_10992_Mallick_Assam_2002       mdr1:86:Y               19        25 p <- s$get_prevalence(\"mdr1:184:F\") #View(p) s$get_variants() #> [1] \"crt:76:T\"   \"k13:469:F\"  \"k13:469:Y\"  \"k13:539:T\"  \"k13:580:Y\"  #> [6] \"k13:675:V\"  \"mdr1:184:F\" \"mdr1:86:Y\" s$drop_study(drop_study_ID = \"wwarn_10297_Nelson\") s #> Studies: 6 #> Surveys: 23"},{"path":"/articles/tutorial_calculating_prevalence.html","id":"calculating-prevalence","dir":"Articles","previous_headings":"","what":"Calculating prevalence","title":"Calculating Prevalence","text":"begin creating new STAVE object appending example data: calculating prevalence, often useful inspect set variants encoded object: default, get_variants() lists single-locus variants (report_haplo = FALSE). instead want see multi-locus haplotypes, set:","code":"# create new object s <- STAVE_object$new()  # append example data s$append_data(studies_dataframe = example_input$studies,               surveys_dataframe = example_input$surveys,               counts_dataframe = example_input$counts) #> data correctly appended s$get_variants() #> [1] \"crt:76:T\"  \"k13:469:F\" \"k13:469:Y\" \"k13:675:V\" \"mdr1:86:Y\" s$get_variants(report_haplo = TRUE) #> [1] \"crt:76:T\"  \"k13:469:F\" \"k13:469:Y\" \"k13:675:V\" \"mdr1:86:Y\""},{"path":"/articles/tutorial_calculating_prevalence.html","id":"prevalence-at-a-single-locus","dir":"Articles","previous_headings":"Calculating prevalence","what":"Prevalence at a single locus","title":"Calculating Prevalence","text":"calculate prevalence specific variant, use get_prevalence(). example, prevalence mutation crt:76:T: output joined table containing study, survey, count information, well estimated prevalence 95% confidence interval survey. Note row returned every loaded survey, even denominator zero. return surveys non-zero denominators, use:","code":"s$get_prevalence(target_variant = \"crt:76:T\") s$get_prevalence(target_variant = \"crt:76:T\", return_full = FALSE)"},{"path":"/articles/tutorial_calculating_prevalence.html","id":"prevalence-of-a-haploype-and-ambiguous-matches","dir":"Articles","previous_headings":"Calculating prevalence","what":"Prevalence of a haploype, and ambiguous matches","title":"Calculating Prevalence","text":"another example, time allowing ambiguous matches. min max numerator now given. example ambiguity calculating prevalence single locus, longer haplotypes min max can differ. prevalence 95% CI calculated using either min max values, specified prev_from_min argument.","code":"s$get_prevalence(\"crt:76:T\", keep_ambiguous = TRUE, prev_from_min = TRUE)"},{"path":"/articles/tutorial_reading_in_data.html","id":"reading-in-data","dir":"Articles","previous_headings":"","what":"Reading in data","title":"Reading in Data","text":"STAVE works via single class (R6 object) acts main data container. class allows users efficiently import, store, manipulate data via specialized member functions. new object can created data read like : default print method tells us many studies surveys loaded: example uses example_input object comes pre-loaded package - look object get feel required input format (see rest package documentation rigorous specification). Using custom class offers several key advantages. loaded, data remain consolidated within single object, avoiding fragmentation. class structure also ensures data encapsulated, meaning directly edited user. built-protection minimizes risk accidental data corruption. can view loaded tables using get functions: However, directly modify data tables. Instead, drop studies surveys using member functions.","code":"# create new object s <- STAVE_object$new()  # append data using a member function s$append_data(studies_dataframe = example_input$studies,               surveys_dataframe = example_input$surveys,               counts_dataframe = example_input$counts) #> data correctly appended s #> Studies: 2 #> Surveys: 6 s$get_studies() s$get_surveys() s$get_counts()"},{"path":"/articles/tutorial_reading_in_data.html","id":"dropping-studies-and-surveys","dir":"Articles","previous_headings":"","what":"Dropping studies and surveys","title":"Reading in Data","text":"Imagine interested study Dama et al. (2017), want drop analysis. can via study_id: Similarly, may want drop specific survey - example Asua_2019_Agago_2017 survey: Looking STAVE object, can see reduced size data:","code":"s$drop_study(\"Dama_2017\") #> drop 1 study, 1 survey s$drop_survey(\"Asua_2019_Agago_2017\") #> drop 0 studies, 1 survey s #> Studies: 1 #> Surveys: 4"},{"path":"/articles/variant_strings.html","id":"gene-name-locus-and-amino-acid-are-separated-by","dir":"Articles","previous_headings":"","what":"1. Gene name, locus, and amino acid are separated by ;","title":"Encoding Variants as Strings","text":"three key elements. example, string pfk13;580;Y specifies pfk13 gene (kelch 13 gene, implicated Artemisinin resistance) 580th codon position, observed amino acid Y. Amino acids must follow IUPAC single-letter format, case Y corresponds Tyrosine. Another common notation call C580Y variant. refrain notation : notation scale well multiple loci. Sources always report wild type (Cysteine case), forcing us extra work tracking reference genome. Strictly, assume non-numerator observations wild type. denominator may include variants, case recording wild type corruption original data. Gene names must consist solely lowercase English letters digits (0-9), without hyphens special characters. Otherwise, follow strict convention. recognise creates potential ambiguity, example two sources use slightly different names gene, pfk13 k13. However, can avoided manually listing gene names existing data using get_variants() function appending new data.","code":""},{"path":"/articles/variant_strings.html","id":"loci-are-separated-by-_","dir":"Articles","previous_headings":"","what":"2. Loci are separated by _","title":"Encoding Variants as Strings","text":"cases, sources may report variants multiple loci. good example pfcrt gene, implicated resistance Amodiaquine among antimalarials, different haplotypes confer different degrees resistance. , variant string pfcrt;72_73_74_75_76;C_V_I_E_T specifies codon 72 observed C (Cysteine), codon 73 observed V (Valine), etc. concise shorthand notation, underscores amino acids can omitted, resulting pfcrt;72_73_74_75_76;CVIET. However, essential retain underscores codon positions prevent ambiguity numbers. data source provides full haplotype, always store haplotype whole. manually break individual loci, example one entry pfcrt;72;C, separate entry pfcrt;73;V etc. calculating prevalence, STAVE smart enough know pfcrt;72;C variant contained within pfcrt;72_73_74_75_76;CVIET haplotype. Even importantly, store haplotype single locus information, lead mistakes prevalence calculation due double-counting. detailed explanation issue, along guidance handling long haplotypes derived raw sequence data, provided next page.","code":""},{"path":"/articles/variant_strings.html","id":"genes-are-separated-by","dir":"Articles","previous_headings":"","what":"3. Genes are separated by :","title":"Encoding Variants as Strings","text":"may want capture information mutations observed together across multiple genes. key example antimalarial combination therapy sulfadoxine-pyrimethamine (SP), resistance arises mutations two genes: Mutations pfdhfr gene reduce parasite’s susceptibility pyrimethamine. Mutations pfdhps gene reduce susceptibility sulfadoxine. can represented variant string format listing multiple genes separated colon. example: pfdhfr;51;:pfdhps;437;G. order genes listed matter, STAVE automatically sort calculating prevalence. Additionally, restriction number genes can included single variant string.","code":""},{"path":"/articles/variant_strings.html","id":"unphased-mixed-calls-are-indicated-by","dir":"Articles","previous_headings":"","what":"4. Unphased mixed calls are indicated by /","title":"Encoding Variants as Strings","text":"Polyclonal infections common malaria can result mixed, “heterozygous,” calls DNA level. cases, mixed calls also manifest amino acid level. occurs, observed amino acids listed, separated forward slash. example, string pfmdr1;76;N/Y indicates pfmdr1 gene codon position 76, N (Asparagine) Y (Tyrosine) observed. number alleles can listed, pfmdr1;76;N/Y/F, indicating three amino acids — N, Y, F (Phenylalanine) — detected position 76. mixed calls can also incorporated multi-locus notation. instance, pfmdr1;76_184;N/Y_Y specifies heterozygous call position 76 (N/Y) homozygous call position 184 (Y).","code":""},{"path":"/articles/variant_strings.html","id":"phased-mixed-calls-are-indicated-by","dir":"Articles","previous_headings":"","what":"5. Phased mixed calls are indicated by |","title":"Encoding Variants as Strings","text":"forward slash notation assumes variants unphased, meaning know variants go together. example, string pfmdr1;76_184;N/Y_Y/F know caused haplotype combination N_Y + Y_F, combination N_F + Y_Y. also two genotypes present sample, case combinations possible. cases, may phased information, meaning know variants go together. can indicated using vertical bar symbol place forward slash. using notation, first letter listed locus always goes first letter another locus, etc. example, pfmdr1;76_184;N|Y_Y|F indicates haplotype combination N_Y + Y_F. number alleles can listed, number alleles must present heterozygous loci. example, observed three distinct amino acids position 76 two distinct amino acids position 184, must list three amino acids locus 184 even means repeating letter. Otherwise possible link amino acids go together. limitations format. example, phased unphased regions currently supported variant. Similarly, partial phasing supported, mean samples two genomes subset genomes phased together. rule thumb, remember / | symbols used together. recognise limitation format, relatively rare edge cases. also tend impact prevalence calculation unless interested prevalence long haplotype. cases , data can still included STAVE format information loss, example treating loci unphased.","code":""},{"path":"/articles/variant_strings.html","id":"what-cannot-be-encoded","dir":"Articles","previous_headings":"","what":"What cannot be encoded?","title":"Encoding Variants as Strings","text":"data format, inherent trade-offs variant string encoding. following information encoded: Copy number variation complex genomic rearrangements, including insertions deletions Combinations phased unphased regions partial phasing (see ) Within-sample allele frequencies Quality scores Keep mind STAVE designed facilitate data extraction diverse sources purposes prevalence calculation. intended replace individual-level data raw sequence data, remain essential types analyses. next page explains prevalence calculated encoding.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Bob Verity. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Verity B (2025). STAVE: Spatial-Temporal Aggregated Variant Encoding. R package version 2.0.0.","code":"@Manual{,   title = {STAVE: Spatial-Temporal Aggregated Variant Encoding},   author = {Bob Verity},   year = {2025},   note = {R package version 2.0.0}, }"},{"path":"/index.html","id":"what-stave-is-designed-to-do","dir":"","previous_headings":"","what":"What STAVE is designed to do","title":"Spatial-Temporal Aggregated Variant Encoding","text":"STAVE focuses small number key tasks commonly cause errors inconsistencies MMS workflows: Provide simple, relational data structure storing study metadata, survey-level space–time information, aggregated genetic counts. Encode amino-acid haplotypes compact, human-readable format using variantstring format. Support robust prevalence estimation, even variants represent subsets longer haplotypes mixed calls introduce uncertainty. STAVE deliberately minimal: attempt handle individual-level data, nucleotide-level data, downstream spatial modelling. Instead, aims slot cleanly broader analysis workflows providing reliable unambiguous foundation steps can build.","code":""},{"path":"/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting started","title":"Spatial-Temporal Aggregated Variant Encoding","text":"learn STAVE data structure works, see works. ’re ready, visit: Installation – install package Tutorials – practical examples common tasks","code":""},{"path":"/reference/STAVE_object.html","id":null,"dir":"Reference","previous_headings":"","what":"STAVE data object (R6 class) — STAVE_object","title":"STAVE data object (R6 class) — STAVE_object","text":"main class stores data responsible data input, output, processing functions. functionality STAVE package class form member functions.","code":""},{"path":"/reference/STAVE_object.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"STAVE data object (R6 class) — STAVE_object","text":"raw data stored private variables within object, meaning () edited directly. Rather, tables can extracted using get_counts() similarly tables. three tables : studies: Information data came , example url     author names. study indexed unique study_id. surveys: Information surveys represented within study.     survey defined discrete instance data collection,     includes information geography (latitude longitude) collection     time. Surveys given survey_ids linked particular study     study_id. counts: actual genetic information, linked     particular study survey study_id survey_id. Genetic     variants encoded character strings must follow specified     format, number times variant observed among total     sample stored columns. combination linked tables allows efficient flexible encoding variants, avoiding unnecessary duplication information.","code":""},{"path":[]},{"path":"/reference/STAVE_object.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"STAVE data object (R6 class) — STAVE_object","text":"STAVE_object$print() STAVE_object$get_studies() STAVE_object$get_surveys() STAVE_object$get_counts() STAVE_object$get_version() STAVE_object$append_data() STAVE_object$get_prevalence() STAVE_object$get_variants() STAVE_object$drop_study() STAVE_object$drop_survey() STAVE_object$clone()","code":""},{"path":"/reference/STAVE_object.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"STAVE data object (R6 class) — STAVE_object","text":"Custom print method control console output","code":""},{"path":"/reference/STAVE_object.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$print()"},{"path":"/reference/STAVE_object.html","id":"method-get-studies-","dir":"Reference","previous_headings":"","what":"Method get_studies()","title":"STAVE data object (R6 class) — STAVE_object","text":"Extract studies data.frames stored within object","code":""},{"path":"/reference/STAVE_object.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_studies()"},{"path":"/reference/STAVE_object.html","id":"method-get-surveys-","dir":"Reference","previous_headings":"","what":"Method get_surveys()","title":"STAVE data object (R6 class) — STAVE_object","text":"Extract surveys data.frames stored within object","code":""},{"path":"/reference/STAVE_object.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_surveys()"},{"path":"/reference/STAVE_object.html","id":"method-get-counts-","dir":"Reference","previous_headings":"","what":"Method get_counts()","title":"STAVE data object (R6 class) — STAVE_object","text":"Extract counts data.frames stored within object","code":""},{"path":"/reference/STAVE_object.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_counts()"},{"path":"/reference/STAVE_object.html","id":"method-get-version-","dir":"Reference","previous_headings":"","what":"Method get_version()","title":"STAVE data object (R6 class) — STAVE_object","text":"Extract version number STAVE object. important member functions STAVE object directly linked object , updated updating version package environment. update STAVE object new package version, first extract data load new STAVE object created recent version.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_version()"},{"path":"/reference/STAVE_object.html","id":"method-append-data-","dir":"Reference","previous_headings":"","what":"Method append_data()","title":"STAVE data object (R6 class) — STAVE_object","text":"Append new data","code":""},{"path":"/reference/STAVE_object.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$append_data(   studies_dataframe,   surveys_dataframe,   counts_dataframe )"},{"path":"/reference/STAVE_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"studies_dataframe data frame containing information study level. data frame must following columns: study_id, study_label, description, access_level, contributors, reference, reference_year, notes. Compulsory fields (missing values) : study_id reference. surveys_dataframe data frame containing information survey level. data.frame must following columns: study_id, survey_id, country_name, site_name, latitude, longitude, location_method, location_notes, collection_start, collection_end, collection_day, time_method, time_notes. Compulsory fields (missing values) : study_id, survey_id, latitude, longitude, collection_day. counts_dataframe data.frame genetic information. Must contain following columns: study_id, survey_id, variant_string, variant_num, total_num. fields compulsory (missing values).","code":""},{"path":"/reference/STAVE_object.html","id":"method-get-prevalence-","dir":"Reference","previous_headings":"","what":"Method get_prevalence()","title":"STAVE data object (R6 class) — STAVE_object","text":"Calculate prevalence","code":""},{"path":"/reference/STAVE_object.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_prevalence(   target_variant,   keep_ambiguous = FALSE,   prev_from_min = TRUE,   return_full = TRUE )"},{"path":"/reference/STAVE_object.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"target_variant variant calculate prevalence, example crt:72:C. can heterozygous calls within string. keep_ambiguous may variants data target_variant sample, proven conclusively. example, sequence A_A_A may match sequence /C_A/C_A, may . unphased genotypes sure. keep_ambiguous = TRUE min max numerator reported either include ambiguous calls matches (max) exclude mismatches (min). FALSE (default) ambiguous calls skipped , may downwardly bias prevalence calculation. prev_from_min output object includes point estimate prevalence along exact binomial confidence intervals. case ambiguous calls, must calculated one numerator_min numerator_max. argument sets one values used calculation. Defaults TRUE, risks underestimating prevalence (whereas alternative risks overestimating prevalence). return_full TRUE (default) returns entire loaded dataset, prevalence equal NA denominator. FALSE returns entries non-zero denominator. @import dplyr @importFrom tidyr replace_na","code":""},{"path":"/reference/STAVE_object.html","id":"method-get-variants-","dir":"Reference","previous_headings":"","what":"Method get_variants()","title":"STAVE data object (R6 class) — STAVE_object","text":"Return vector variants present data object.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$get_variants(report_haplo = FALSE)"},{"path":"/reference/STAVE_object.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"report_haplo (Boolean) TRUE list haplotypes. Otherwise, list locus--locus format. Defaults FALSE.","code":""},{"path":"/reference/STAVE_object.html","id":"method-drop-study-","dir":"Reference","previous_headings":"","what":"Method drop_study()","title":"STAVE data object (R6 class) — STAVE_object","text":"Drop one study_ids data. drop internally stored data objects, including corresponding surveys counts data.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$drop_study(drop_study_id)"},{"path":"/reference/STAVE_object.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"drop_study_id vector study_ids drop data objects.","code":""},{"path":"/reference/STAVE_object.html","id":"method-drop-survey-","dir":"Reference","previous_headings":"","what":"Method drop_survey()","title":"STAVE data object (R6 class) — STAVE_object","text":"Drop one survey_ids data. drop internally stored data objects, including corresponding counts data, study survey study.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$drop_survey(drop_survey_id)"},{"path":"/reference/STAVE_object.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"drop_survey_id vector survey_ids drop data objects.","code":""},{"path":"/reference/STAVE_object.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"STAVE data object (R6 class) — STAVE_object","text":"objects class cloneable method.","code":""},{"path":"/reference/STAVE_object.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"STAVE data object (R6 class) — STAVE_object","text":"","code":"STAVE_object$clone(deep = FALSE)"},{"path":"/reference/STAVE_object.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"STAVE data object (R6 class) — STAVE_object","text":"deep Whether make deep clone.","code":""},{"path":"/reference/allowed_amino_acids.html","id":null,"dir":"Reference","previous_headings":"","what":"String of allowed amino acids — allowed_amino_acids","title":"String of allowed amino acids — allowed_amino_acids","text":"Returns data.frame allowed amino acid single-letter codes. come IUPAC (International Union Pure Applied Chemistry), see details. Variants defined variant_string column counts data.frame must one single-letter codes, otherwise underscore (_), pipe (|) forward slash (/) symbols. Underscores removed allowed improved readability. pipe forward slash symbols represent phased unphased mixed calls, respectively.","code":""},{"path":"/reference/allowed_amino_acids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"String of allowed amino acids — allowed_amino_acids","text":"","code":"allowed_amino_acids()"},{"path":"/reference/disallowed_variant_strings.html","id":null,"dir":"Reference","previous_headings":"","what":"Examples of invalid variant strings — disallowed_variant_strings","title":"Examples of invalid variant strings — disallowed_variant_strings","text":"Returns data.frame invalid variant strings, along reason invalid. Can useful understanding correct format. Also, data.frame used internal package testing, .e. every row data.frame return error.","code":""},{"path":"/reference/disallowed_variant_strings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Examples of invalid variant strings — disallowed_variant_strings","text":"","code":"disallowed_variant_strings()"},{"path":"/reference/example_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Input Dataset — example_input","title":"Example Input Dataset — example_input","text":"list containing three data.frames make STAVE object. correctly formatted, can used reference formatting data. studies come much reduced version WWARN data antimalarial resistance.","code":""},{"path":"/reference/example_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Input Dataset — example_input","text":"","code":"example_input"},{"path":"/reference/example_input.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Input Dataset — example_input","text":"list containing three data.frames","code":""},{"path":"/reference/example_input.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example Input Dataset — example_input","text":"","code":"data(\"example_input\", package = \"STAVE\")"}]
